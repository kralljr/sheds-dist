--- 
title: "Run Bayesian model" 
output: 
  html_document: 
    toc: true 
    number_sections: true 
    theme: cosmo 
    toc_depth: 2
---


```{r lib, warning F, message F, echo = F}
# File to test mcmc_corr.R
library(mvtnorm)
library(truncnorm)
library(MESS)
library(knitr)


opts_chunk$set(message = F, fig.align = "center", warning = F, echo = F)
```




```{r}

# Howard to-do
# DONE 1. Simulate beta1 individually
# DONE 2. Use real data
# DONE 3. Use more complicated beta: use phi to draw beta
# 3b. Use a functional beta
# DONE 4. Random x's- check correlation in x's: correlation in simulated is very high


# 5. Separate out median effect
# 6. Other MV approach- book? 

```


```{r info}

# CHECK! Works for nothing
# CHECK!  Works for beta0


# Set up dimensions and x
ny <- 2000
na <- 1000
set.seed(10)
x1 <- matrix(rtruncnorm(ny * na, mean = 15, a = 0, sd = 1.5), nrow = ny)


# Add shift to x
shift <-  matrix(rep(runif(ny, min = -5, max = 20), each = na), ncol = na, byrow = T)
x1 <- x1 + shift

fp1 <- "~/Documents/SHEDS"
x1 <- read.csv(file.path(fp1, "sim_dates_winter.csv"))
xall <- read.csv(file.path(fp1, "sim_dates_summer.csv"))
x1 <- cbind(x1, xall)


x1 <- t(x1)

ny <- nrow(x1)
na <- ncol(x1)


# Set up quantiles and x
quants1 <- c(0.7, 0.9)
quants1 <- seq(0.01, 0.99, length = 10)
quants1 <- seq(0.05, 0.95, by = 0.05)

# quants1 <- seq(0, 1, by = 0.02)


# x <- apply(x1, 1, quantile, probs = c(0.1, 0.25, 0.5, 0.75, 0.9))
x <- apply(x1, 1, quantile, probs = quants1)


x <- t(x)


# Try and scale?
mnx <- apply(x, 2, mean)
x <- sweep(x, 2, mnx)
sdx <- apply(x, 2, sd)
x <- sweep(x, 2, sdx, "/")

#Random x
n1 <- nrow(x)
n1 <- 2000
set.seed(21649)
#x <- matrix(rnorm(n1 * ncol(x)), nrow = n1)
```



# Generate beta1
```{r}

# Get dists
np <- ncol(x)
seq1 <- rep(quants1, each = np)
rows <- matrix(seq1, nrow = np, byrow = T)
cols <- matrix(seq1, nrow = np, byrow = F)
Dists <- abs(rows - cols)


# Set phi and sigma
phi <- 2 #1 works
corr <- exp(-1 / phi * Dists)
Sigma <- 0.1 * corr

#set.seed(200)
#s1 <- sample(seq(1, 10000), 1)

# Version that works?
s1 <- 5021

s1 <- sample(seq(1, 10000), 1)
print(s1)

s1 <- 8342
set.seed(s1)
beta1 <- rmvnorm(1, sigma = Sigma) 
beta1
beta1a <- beta1

plot(quants1, beta1a, ylim = c(0, 1))
```





```{r}

beta0 <- 0

# Try for beta1
# Issues:
# 1. Low acceptance probability (incorporate correlation?)
beta1 <- rep(0.1, ncol(x))
beta1a <- beta1

#lmu <- rowSums(sweep(x, 2, beta1, "*"))
lmu <- sweep(x, 2, beta1, "*")
lmu <- rowSums(lmu) * 1/length(beta1)
#lmu <- apply(lmu, 1, function(x) auc(quants1, x))
lmu <- lmu + beta0

#phi <- 0
#beta0 <- 0
#beta1 <- rep(10, 10)
#sigma2 <- 1
#guessvec1 <- list(beta0 = beta0, beta1 = beta1, phi = phi, sigma2 = sigma2)
```



```{r run, eval = T}

source("mcmc_corr.R")

# Give guessvec
guessvec1 <- list()
guessvec1$beta0 <- 1
b1 <- t(matrix(rep(1, length(quants1))))
guessvec1$beta1 <- b1
guessvec1$phi <- .2
guessvec1$sigma2 <- .01

# Set seed
set.seed(10)
y <- rpois(ny, exp(lmu))
N <- 10000
m1 <- mcmcout(y, x, quants = quants1, niter = N, burnin = 0, thin = 1, guessvec = guessvec1)
save(m1, file = "test_mcmc_howard.RData")
```


```{r}

source("mcmc_corr.R")

# try simulated data

load("sbeta_shift.RData")
rs1 <- runsim1$simout1[[9]]
quants1 <- rs1$argvals1
beta1a <- rs1$betaf(quants1)


set.seed(10)
N <- 25000
m1 <- mcmcout(rs1$y1, t(rs1$x1$x1), quants = quants1, niter = N, burnin = 0, thin = 1, type = "norm")
save(m1, file = "norm_x2_sbeta_shift.RData")


```





# Summary statistics for data

## Acceptance probabilities
```{r tabs}
#load("test_mcmc_howard.RData")
acc1 <- cbind(names(m1$accept), round(m1$accept / N, 2))
colnames(acc1) <- c("Parameter", "Acceptance Probability")
rownames(acc1) <- NULL
kable(acc1)
```

## Posterior means for beta1
```{r tabs2}
n <- 15000
#N <- length(m1$sigma2)
ns <- seq(n, N, by = 10)
m1ba <- apply(m1$beta1[ns, ], 2, mean)
m1b <- data.frame(round(quants1, 2),  round(m1ba, 3), as.numeric(round(beta1a, 2)))
colnames(m1b) <- c("Quantile", "Posterior mean", "Truth")
kable(m1b)
```

## Posterior means for other parameters
```{r tabs3}
sigma2 <- mean(m1$sigma2[ns])
phi <- mean(m1$phi[ns])
beta0 <- mean(m1$beta0[ns])
post <- cbind(c("sigma2", "phi", "beta0"), round(c(sigma2, phi, beta0), 4))
colnames(post) <- c("Parameter", "Posterior mean")
kable(post)
```



# Plots for convergence 
```{r plot}
plot(m1$beta0, ylab = "Beta0", xlab = "Iteration")
plot(m1$sigma2, ylab = "Sigma2", xlab = "Iteration")
plot(m1$phi, ylab = "Phi", xlab = "Iteration")

plot(m1$beta1[, 1], ylab = "Beta1_1", xlab = "Iteration")
plot(m1$beta1[, 2], ylab = "Beta1_2", xlab = "Iteration")
```

# Plot of posterior means for beta1
```{r plot2}
beta1 <- m1$beta1[ns, ] 


ymin <- -.01
ymax <- .1

m1ba <- apply(beta1, 2, median)
plot(m1b[, 1], m1ba, type = "l", ylim = c(ymin, ymax), xlab = "Quantile", ylab = "Beta1")
legend("topright", legend = c("Post. Mean", "95% PI", "Truth"), lty = c(1, 2, 1), col = c("black", "blue", "red"))


lbub <- apply(beta1, 2, quantile, probs = c(0.025, 0.975))
points(m1b[, 1], lbub[1, ], type = "l", col = "blue", lty = 2)

points(m1b[, 1], lbub[2, ], type = "l", col = "blue", lty = 2)

#abline(h = 0.1, col = "red")

points(m1b[, 1], beta1a, col = "red", type = "l")
```
